\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{hyperref}
\usepackage{a4wide}
\hypersetup{pdftitle={Sistema de Gestão de Stocks},
pdfauthor={José Ferreira, João Teixeira},
colorlinks=true,
urlcolor=blue,
linkcolor=black}
\usepackage{subcaption}
\usepackage[cache=false]{minted}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{appendix}
\usepackage{tikz}
\usepackage{authblk}
\usetikzlibrary{positioning,automata,decorations.markings}

\begin{document}

\title{Gestão de Stocks\\ 
\large Grupo Nº 2}
\author{José Ferreira (A83683) \and João Teixeira (A85504)}
\date{\today}

\begin{center}
    \begin{minipage}{0.75\linewidth}
        \centering
        \includegraphics[width=0.4\textwidth]{eng.jpeg}\par\vspace{1cm}
        \vspace{1.5cm}
        \href{https://www.uminho.pt/PT}
        {\color{black}{\scshape\LARGE Universidade do Minho}} \par
        \vspace{1cm}
        \href{https://www.di.uminho.pt/}
        {\color{black}{\scshape\Large Departamento de Informática}} \par
        \vspace{1.5cm}
        \maketitle
    \end{minipage}
\end{center}

\tableofcontents

\pagebreak

\chapter{Introdução}

O objetivo deste projeto é construir um sistema de gestão de stocks,
de forma a ser capaz de armazenar informacao de artigos, stocks e vendas,
aplicando uma arquitetura \textit{Cliente, Servidor} com recurso a \textit{System Calls}
e varios processos, aplicando assim os conhecimentos sobre os Sistema Operativos 
baseados em Unix adquiridos nas aulas desta UC\@.
Como objetivo, é necessário implementar um sistema que permita a utilização concorrente de 
um servidor por vários clientes, assegurando a conservação de toda a informação
introduzida no sistema, bem como a consistencia da mesma pelos vários ficheiros
e cache.\\
Ao longo deste relatório vamos descrever as nossas abordagens a estes problemas.

\chapter{Módulos e API}\label{chap:api}

\section{Manutencao de Artigos}

O modulo da Manutencao de artigos tem como funcao ser um `precario'
tendo informacao dos diferentes produtos existentes, bem como o seu
preco. Aqui e possivel a criacao de novos artigos, bem como a sua
modificacao. Sendo um modulo referente a manutencao, tambem e possivel
correr o agregador a pedido.

\section{Servidor de Vendas}

O Servidor de vendas trata todos os pedidos dos Clientes de vendas,
quer sejam vendas ou entradas de stock, ou informacoes sobre o preco
e stocks existentes no momento.

\section{Cliente de Vendas}

O Cliente de Vendas e a interface que o utilizador final usa para
realizar todas as vendas e pedidos de informacao, comunicando com
o servidor de vendas.

\section{Agregador}

O Agregador tem como finalidade agregar vendas, ou seja, juntar
todas as vendas referentes ao mesmo artigo.

\chapter{Arquitetura e Solucao do Projeto}

\section{Manutencao de Vendas}

A Manutencao de Vendas trata de manter artigos, respetivos precos
e nomes. Para manter essa informacao usa dois ficheiros, \textit{strings}
e \textit{artigos}. O utilizador consegue adicionar e modifificar artigos
atraves do stdin. Embora a manutencao de vendas seja independente dos 
restantes modulos, este comunica com o Servidor de Vendas, caso este esteja
a correr, de forma a manter a sincronizacao  da informacao sobre o preco 
e numero de aritgos existentes em ambos os lados.

\section{Servidor de Vendas}

O Servidor de Vendas trata dos pedidos de todos os clientes, e trata de 
manter informacao sobre o stock de cada artigo. Para manter essa informacao
utiliza o ficheiro \textit{stocks}. O Servidor corre em background, consistindo
em tres diferentes processos:
\begin{itemize} 
    \item Um que trata da sincronizacao com a
        parte da Manutencao de Artigos (precos e criacao de novos artigos), com a
        finalidade de manter, tanto o ficheiro de stocks, como a cache de precos
        sempre atualizada.
    \item Um que contem a cache de precos.
    \item Um responsavel pela comunicacao e tratamento dos pedidos dos clientes
\end{itemize}

\section{Apresentação}

A apresentação contém apenas um módulo, o view. Este contém funções de apresentação genérica,
tais como funções para apresentar array de strings e funções para apresentar matrizes de inteiros.

\chapter{Estruturas de dados}

Como descrito no capítulo\ref{chap:api}, todas as nossas estruturas de dados consistem 
em Hashtables da GLib, escolha feita após múltiplos testes empíricos de abordagens distintas.\\
Numa abordagem inicial, na primeira fase do projeto, utilizamos arrays para 
guardar os dados. Para esta abordagem, observamos tempos de leitura e validação de ficheiros
superiores a 5 minutos.\\
Numa segunda abordagem, no inicio da segunda fase, optamos por utilizar 
Árvores Auto-Balanceadas da biblioteca GLib, onde os tempos de leitura e validação 
dos ficheiros baixaram para cerca de 7 segundos, graças à pesquisa $O(\log N)$,
operação mais utilizada na validação das vendas.\\
Como abordagem final, implementamos Hashtables, também da biblioteca GLib.
Nesta, os valores não são armazenados de forma ordenada. No entanto,
tal como concluímos com esta versão, com ferramentas tão otimizadas para a ordenação
como o \textit{qsort()} da linguagem de programação C, a inserção ordenada acaba por ter
um impacto demasiado negativo nos tempos de inserção.\\
Por um lado, graças ao tempo de inserção e pesquisa $O(1)$, conseguimos reduzir
o tempo de carregamento de ficheiros para menos de 4 segundos, como descrito
na tabela, um melhoramento de aproximadamente 40\%.\\
Por outro lado, graças à implementação otimizada das Hashtables na biblioteca em uso,
percorrer todos os elementos desta, de acordo com os nossos testes, é tão rápido como
na implementação anterior de AVLs. Tal resulta num tempo de resposta a queries
inalterado quando comprado com a implementação anterior.\\
Assim, com a utilização de Hashtables conseguimos uma melhoria de
aproximadamente 40\% nos tempos de \textit{load} e manter os mesmos resultados nos
tempos de resposta a queries.

\chapter{Testes e Benchmarks}

Durante a execução do nosso projeto, foram efetuados diversos testes ao código, com
ferramentas como \textit{Valgrind}, para verificar a presença de \textit{memory 
leaks}, \textit{memusage}, para fazer proffiling à memoria utilizada, \textit{gprof}
para ver quais funções pesam mais na execução do programa, com vista a otimizar as
partes mais lentas, e para medição dos tempos de execução utilizamos a biblioteca
\textit{time.h}.

\section{Memória}

Utilizando a ferramenta \textit{Valgrind}, conseguimos verificar que o programa
corre sem \textit{memory leaks}, à exceção de algumas causadas pela biblioteca
\textit{glib}.\\

Com a ferramenta \textit{memusage}, obtivemos o gráfico de uso de memória presente
na figura, concluindo que as nossas estruturas preenchidas com
os dados dados, estão a consumir, em pico, por volta dos 360MB.

\chapter{Conclusão}

Para concluir, conseguimos cumprir todos os requisitos propostos, conseguindo implementar
todos os módulos e estrutura-los como pedido, sendo assim capaz de responder a todas as 
queries da forma que nos pareceu mais eficiente.\\
Como trabalho futuro, gostaríamos de conseguir melhorar os tempos de load de ficheiros,
no caso do ficheiro de um milhão de vendas, para tempos inferiores a 2 segundos, e
gostaríamos também de fazer ligeiras mudanças à estruturação das APIs de alguns dos 
módulos, para no futuro, ser mais fácil de responder a novas queries caso fosse 
necessário.

\appendix

\end{document}
